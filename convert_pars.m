% convert_pars.m% function mv = convert_pars(gvals)% gvals conversion utility% JBB 2/20/04% Modified to extract only the trial parameters, not the sampled data for each trial.% rmm august 01, 2004% NOTE: getfield and setfield do not work with nested structures; use eval() instead.function master_struct = convert_pars(gvals)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ARGUMENT AND USER INPUT HANDLING%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% no arguments: general helpif nargin == 0,	help convert_pars;	returnend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MAIN PROCESSING CODE%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% types for structure dataEMPTY = -1;SCALAR = 0;VECTOR = 1;		% always column (converted if necessary)MATRIX = 2;		% 2-D maxCELL_STR = 3;	% single string in cell% exclude these fields from analysisexcluded_fields = {'debug.loop_timer', 'raw', 'ctr', 'h_eye', 'v_eye', 'h_vel', 'v_vel', 'ls'};ntrials = length(gvals);% phase 1: get flattened list of all structure tree fields for easy accessflattened_fieldlist = TraverseStruct(gvals(1), [], []);for j = 1:length(excluded_fields),	idx = strmatch(excluded_fields{j}, flattened_fieldlist);	flattened_fieldlist(idx, :) = [];end% phase 2: cycle through fields to check type and expected size% if type is variable length (scalar / vector / matrix) scan all structures to get needed size% after size and type are determined initialize master data structureftype = ones(length(flattened_fieldlist), 1) .* -1;		% type of data in each fieldfsize = ones(length(flattened_fieldlist), 2) .* -1;		% size of data in each fieldmaster_struct = [];for fd = 1:length(flattened_fieldlist),	field = flattened_fieldlist(fd, :);	% cycle trials to get final types and sizes for field, if necessary	tr = 1;	while tr > 0 & tr <= ntrials,		% can exit loop with tr = -1;		try			eval(sprintf('data = gvals(tr).%s;', field));	% read field data		catch			data = nan;		end		fsize(fd, :) = max(fsize(fd, :), size(data));	% update size		% determine type		if iscell(data),				% cell fields			if ischar(data{1}),			% text inside cell				ftype(fd) = CELL_STR;	% set type				eval(sprintf('master_struct.%s = cell(ntrials, 1);', field));	% initialize				end		% end if ischar(data{1}); cell string / cell array initialization			tr = -1;					% can end loop now (finished initializing field)		else							% numeric fields			if isempty(data)				ftype(fd) = max(ftype(fd), EMPTY);			elseif max(fsize(fd, :)) == 1,	% e.g. size == [1 1]: SCALAR field				ftype(fd) = max(ftype(fd), SCALAR);						% do nothing (stay with current type)			elseif min(fsize(fd, :)) == 1,	% e.g. size == [1 3]: VECTOR field				ftype(fd) = max(ftype(fd), VECTOR);	% update field (overwrites SCALAR type)			else						% e.g. size == [2 2]: MATRIX field				ftype(fd) = MATRIX;		% update field (MATRIX overwrites all)			end			tr = tr + 1;				% go to next trial to update this field again		end		% type determination	end			% while: cycle through trials	% now that size of numeric fields have been determined, they can be initialized too	if ftype(fd) == SCALAR | ftype(fd) == EMPTY,				% SCALAR field		tempnull = repmat(NaN, 1, ntrials);						% array of values		eval(sprintf('master_struct.%s = tempnull;', field));	% initialize	elseif ftype(fd) == VECTOR,									% VECTOR field		if fsize(fd, 2) > fsize(fd, 1),		% transpose row to column vector, if needed			fsize(fd, :) = fliplr(fsize(fd, :));		end		tempnull = repmat(NaN, fsize(fd, 1), ntrials);			% padded matrix of values		eval(sprintf('master_struct.%s = tempnull;', field));	% initialize	elseif ftype(fd) == MATRIX,									% MATRIX field		tempnull = repmat(NaN, fsize(fd, 2), ntrials);			% single filler matrix		tempcell = cell(1, fsize(fd, 1));						% cell array length from data #rows		[tempcell{:}] = deal(tempnull);							% fill cell array with null matrices		eval(sprintf('master_struct.%s = tempcell;', field));	% initialize	end			% finished initializing numeric fields	% all fields are initialized, so can start loading data	for tr = 1:ntrials,											% cycle through trials again		try 			eval(sprintf('data = gvals(tr).%s;', field));				% read field data		catch			data = nan;		end		if ftype(fd) == SCALAR,										% SCALAR field			eval(sprintf('master_struct.%s(tr) = data;', field));	% write value		elseif ftype(fd) == VECTOR,									% VECTOR field			if size(data, 1) == 1 & size(data, 2) > 1, data = data'; end	% transpose if needed			eval(sprintf('master_struct.%s(1:length(data), tr) = data;', field));	% write value		elseif ftype(fd) == MATRIX,									% MATRIX field			for i = 1:size(data, 1),		% each row of data is in separate cell				eval(sprintf('master_struct.%s{i}(:, tr) = data(i, :);', field));	% write values			end								% data cols in matrix rows; trials in matrix cols		elseif ftype(fd) == CELL_STR,								% STRING (CELL) field			eval(sprintf('master_struct.%s{tr} = data{1};', field));	% write value		end		% trial type breakdown	end			% cycle through trials (second pass)end				% cycle through fields