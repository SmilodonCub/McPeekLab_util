% convert_pars.m% function mv = convert_pars(gvals)% gvals conversion utility% JBB 2/20/04%% rmm august 01, 2004: Modified to extract only the trial parameters, not the sampled data for each trial.%% rmm feb 08, 2005: Modified to operate on multiple gvals arrays, combining them semi-intelligently.%	The first gvals array determines which fields will exist in the final combined struct.%	Multiple gvals arrays as passed as cell structs (i.e., gvals{1}, gvals{1}). These are referred to %	as "blocks", they are typically loaded from two different data files that are meant to be combined.%% Note: backwards compatible with the old convert_pars.%% NOTE: getfield and setfield do not work with nested structures; use eval() instead.function master_struct = convert_pars2(bvals)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ARGUMENT AND USER INPUT HANDLING%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% no arguments: general helpif nargin == 0,	help convert_pars2;	returnend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MAIN PROCESSING CODE%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% types for structure dataEMPTY = -1;SCALAR = 0;VECTOR = 1;		% always column (converted if necessary)MATRIX = 2;		% 2-D maxCELL_STR = 3;	% single string in cell% exclude these fields from analysisexcluded_fields = {'debug.loop_timer', 'raw', 'ctr', 'h_eye', 'v_eye', 'h_vel', 'v_vel', 'ls'};if iscell(bvals)	nblocks = length(bvals);	gvals = bvals{1};	master_ntrials = 0;	for i = 1:nblocks		master_ntrials = master_ntrials + length(bvals{i});	endelse	nblocks = 1;	gvals = bvals;	master_ntrials = length(gvals);end% phase 1: get flattened list of all structure tree fields for easy accessflattened_fieldlist = TraverseStruct(gvals(1), [], []);for j = 1:length(excluded_fields),	idx = strmatch(excluded_fields{j}, flattened_fieldlist);	flattened_fieldlist(idx, :) = [];end% phase 2: cycle through fields to check type and expected size% if type is variable length (scalar / vector / matrix) scan all structures to get needed size% after size and type are determined initialize master data structureftype = ones(length(flattened_fieldlist), 1) .* -1;		% type of data in each fieldfsize = ones(length(flattened_fieldlist), 2) .* -1;		% size of data in each fieldmaster_struct = [];for fd = 1:length(flattened_fieldlist),	field = flattened_fieldlist(fd, :);		block = 1;	while block > 0 && block <= nblocks		% cycle trials to get final types and sizes for field, if necessary		ntrials = length(gvals);		tr = 1;		while tr > 0 && tr <= ntrials,		% can exit loop with tr = -1;			try				eval(sprintf('data = gvals(tr).%s;', field));	% read field data			catch				data = nan;			end			fsize(fd, :) = max(fsize(fd, :), size(data));	% update size				% determine type			if iscell(data),				% cell fields				if ischar(data{1}),			% text inside cell					ftype(fd) = CELL_STR;	% set type					eval(sprintf('master_struct.%s = cell(ntrials, 1);', field));	% initialize						end		% end if ischar(data{1}); cell string / cell array initialization				tr = -1;					% can end loop now (finished initializing field)				block = -1;				else							% numeric fields				if isempty(data)					ftype(fd) = max(ftype(fd), EMPTY);				elseif max(fsize(fd, :)) == 1,	% e.g. size == [1 1]: SCALAR field					ftype(fd) = max(ftype(fd), SCALAR);						% do nothing (stay with current type)				elseif min(fsize(fd, :)) == 1,	% e.g. size == [1 3]: VECTOR field					ftype(fd) = max(ftype(fd), VECTOR);	% update field (overwrites SCALAR type)				else						% e.g. size == [2 2]: MATRIX field					ftype(fd) = MATRIX;		% update field (MATRIX overwrites all)				end				tr = tr + 1;				% go to next trial to update this field again			end		% type determination		end			% while: cycle through trials			if block > 0			block = block + 1;			if block <= nblocks				gvals = bvals{block};			end		end	end	% now that size of numeric fields have been determined, they can be initialized too	if ftype(fd) == SCALAR || ftype(fd) == EMPTY,				% SCALAR field		tempnull = NaN(1, master_ntrials);						% array of values		eval(sprintf('master_struct.%s = tempnull;', field));	% initialize	elseif ftype(fd) == VECTOR,									% VECTOR field		if fsize(fd, 2) > fsize(fd, 1),		% transpose row to column vector, if needed			fsize(fd, :) = fliplr(fsize(fd, :));		end		tempnull = NaN(fsize(fd, 1), master_ntrials);			% padded matrix of values		eval(sprintf('master_struct.%s = tempnull;', field));	% initialize	elseif ftype(fd) == MATRIX,									% MATRIX field		tempnull = NaN(fsize(fd, 1), master_ntrials);			% single filler matrix		tempcell = cell(1, fsize(fd, 2));						% cell array length from data #rows		[tempcell{:}] = deal(tempnull);							% fill cell array with null matrices		eval(sprintf('master_struct.%s = tempcell;', field));	% initialize	end			% finished initializing numeric fields	% all fields are initialized, so can start loading data	master_tr = 0;		% Indexes trials in the final combined struct.	for block = 1:nblocks		if nblocks > 1			gvals = bvals{block};			ntrials = length(gvals);		end					for tr = 1:ntrials,											% cycle through trials again			try 				eval(sprintf('data = gvals(tr).%s;', field));				% read field data			catch				data = nan;			end				master_tr = master_tr + 1;					if ftype(fd) == SCALAR,										% SCALAR field				eval(sprintf('master_struct.%s(master_tr) = data;', field));	% write value				elseif ftype(fd) == VECTOR,									% VECTOR field				if size(data, 1) == 1 && size(data, 2) > 1, data = data'; end	% transpose if needed				eval(sprintf('master_struct.%s(1:length(data), master_tr) = data;', field));	% write value				elseif ftype(fd) == MATRIX,									% MATRIX field				for i = 1:size(data, 2),		% each row of data is in separate cell					eval(sprintf('master_struct.%s{i}(1:size(data,1), master_tr) = data(:,i);', field));	% write values				end								% data cols in matrix rows; trials in matrix cols				elseif ftype(fd) == CELL_STR,								% STRING (CELL) field				eval(sprintf('master_struct.%s{master_tr} = data{1};', field));	% write value				end		% trial type breakdown		end		% cycle through trials (second pass)	end		% Cycle through blocks%	disp(round(fd ./ length(flattened_fieldlist) .* 100));end		% cycle through fields