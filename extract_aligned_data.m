% based on convert_vals.m% function master_struct = convert_vals(loadfile, savefile, align_state, align_range)% gvals conversion utility% required input:%	loadfile -		experiment data file containing gvals and gpars% optional inputs (program will prompt for these if any are missing or empty):%	savefile -		filename for saving converted data structure%	align_state -	state on which to align trial data (t = 0)%	align_range -	time range over which to save trial data% JBB 2/20/04function master_struct = convert_vals(gvals, data_fields, align_state, align_range)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ARGUMENT AND USER INPUT HANDLING%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% no arguments: general helpif nargin == 0,	help extract_aligned_data;	returnendif nargin < 2 | isempty(data_fields)	data_fields = {'h_eye', 'v_eye', 'ctr'};end% third argument: state to align data on% number  ok% prompt for state if blank or nonexistentif nargin < 3, align_state = []; endif isempty(align_state),	while isempty(align_state),		align_state = input('Enter the state number to align data on >> ');	endend% fourth argument: alignment interval (prompt if blank or nonexistent)if nargin < 4 align_range = []; endwhile isempty(align_range) | size(align_range) ~= 2,	fprintf('Analysis interval format is [x y] in msec, with alignment state being time zero.\n');	align_range = input('Enter interval >> ');end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MAIN PROCESSING CODE%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ntrials = length(gvals);% phase 2: cycle through fields to check type and expected size% if type is variable length (scalar / vector / matrix) scan all structures to get needed size% after size and type are determined initialize master data structuremaster_struct = [];for fd = 1:length(data_fields),	field = data_fields{fd};	if isfield(gvals(1), field)		eval(sprintf('data = gvals(1).%s;', field));	% read field data		if iscell(data) & ~ischar(data{1}),				% cell fields			temp_cellarray = cell(1, length(data));	% match number of data cells (empty for now)			% get sample rates (do not vary trial to trial, so can use later)			% see update_scopewindow.m for notes on data alignment / start times.			if strcmp(fd, 'raw'),		% raw channels				sample_rate = gvals(1).misc.raw_rate;			elseif strcmp(fd, 'ctr'),	% counter channels				sample_rate = gvals(1).misc.ctr_rate;			else										% eye only 3/4/04				sample_rate = gvals(1).misc.eye_rate;			end			% other alignment variables (some used later)			to_msec = 1000 / sample_rate;			% i.e., msec per sample			to_samples = 1 / to_msec;				% i.e., samples per msec			data_length = length([align_range(1)+to_msec : to_msec : align_range(2)]);			% initialize based on computed data length%			for i = 1:length(data),%				if ~isempty(data{i}),					% initialize all non-empty cells%					temp_cellarray{i} = zeros(data_length, ntrials);%				end%			end%			eval(sprintf('master_struct.%s = temp_cellarray;', field));		% initialize (finish)					% all fields are initialized, so can start loading data			for tr = 1:ntrials,											% cycle through trials again				eval(sprintf('data = gvals(tr).%s;', field));				% read field data						for i = 1:length(data),				% each vector of data is in separate cell					if ~isempty(data{i}),			% do not assign if vector is empty (unused channel)							% freshen variables that depend on trial number						if strcmp(fd, 'raw'),		% raw channels							start_time = gvals(tr).misc.hs_start;						elseif ismember(fd, 'ctr'),	% counter channels							start_time = gvals(tr).misc.ctr_start(i);						else										% eye only 3/4/04							start_time = gvals(tr).misc.ls_start;						end						states = [gvals(tr).disp_time; gvals(tr).state_time];						align_index = round((states(align_state) - start_time) * sample_rate);							% align data vector						data{i} = trial_align2(data{i}, align_index, round(align_range*to_samples));						master_struct(:, tr, fd) = data{i};	% write value										end				end			end		% trial type breakdown		end			% cycle through trials (second pass)	end 		% field existsend				% cycle through fields