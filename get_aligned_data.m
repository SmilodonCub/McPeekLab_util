function mv = get_aligned_data(files, nums, nodata, which_fields, align_states, time_windows)% function mv = get_aligned_data(files, nums, nodata, which_fields, align_states, time_windows)%% (Formerly called: plexconvert_any)% This concatenates multiple data files for the same task and the same cell(s).% Data are aligned on specified events. Plexon data from .px files in the same directory are used if specified.%% files - cell array of filename prefixes% nums - cell array of filename suffix numbers% nodata - if this flag is set to 1, then only experiment parameters are extracted; no aligned data are extracted.% which_fields - specifies the data types to extract.% align_states - a cell array of strings listing alignment points for the data. The strings should match behavioral or display states from the experiment program (i.e., 'target on')% time_windows - a cell array of two-element vectors defining the data time windows surrounding the corresponding alignment states. Negative means before the state; positive after.%% for data with matching .px files, calls extract_aligned_data2_plex_lfp% for data without plexon, calls extract_aligned_data2%% examples:% files = {'fr12_objd_'};% nums = {[5:8 11]};%% this combination would matches .mat files starting with fr12_objd_ and ending with 05, 06, 07, 08, 11.%% New version to correct "dissimilar structs" error message.% Note: when combining multiple data files, the first file determines%	which fields will be present in the final struct.% rmm Feb 9, 2005%% Added wildcard expansion to filenames - rmm April 22, 2005.% h_eye, v_eye, ctr, plex, plexlfp, plexwf, plexwfall%% rmm 03/27/2011 - updated to handle spike waveforms and LFPs%if nargin < 5	align_states = {'target on', 'saccade inflight', 'cue on'};	time_windows = {[-100 500], [-500 300], [-800 800]};endif nargin < 4	which_fields = {'h_eye', 'v_eye', 'ctr', 'plex'};endif nargin < 3	nodata = 0;endif nargin < 2	nums = [];endif ~iscell(files)	files = {files};endif ~isempty(nums) & ~iscell(nums)	nums = {nums};endif ~iscell(which_fields)	which_fields = {which_fields};endif ~iscell(align_states)	align_states = {align_states};endif ~iscell(time_windows)	time_windows = {time_windows};endfilelist = [];count = 1;for i = 1:length(files)	if nargin < 2 | isempty(nums) | isempty(nums{i})		d = dir([files{i} '*']);		for j = 1:length(d)			if strcmp(d(j).name(end-3:end), '.mat') == 1				filelist{count} = d(j).name(1:end-4);				count = count + 1;			end		end	else		for j = 1:length(nums{i})			filelist{count} = [files{i} num2str(nums{i}(j), '%02d')];			count = count + 1;		end	endendif ~exist('filelist')	keyboardendcount = 0;successful_files = 0;plex_successful = 1;last_data_name = [];for i = 1:length(filelist)	fprintf('Loading %s\n', filelist{i});	load(filelist{i});	if ~exist('gvals')		fprintf('**File %s is empty.\n', filelist{i});	else		num_trls = length(gvals);		if num_trls > 0			if ~isempty(last_data_name) & strcmp(gvals(1).misc.data_name, last_data_name) == 1				fprintf('Possible duplicate files: %s and %s.\n', filelist{i-1}, filelist{i});				keyboard			else				last_data_name = gvals(1).misc.data_name;			end			successful_files = successful_files + 1;			gvals = solve_cue_nan_problem(gvals);			[gvals.filenum] = deal(successful_files);			bvals{successful_files} = gvals;			count = count + num_trls;			if plex_successful				if ~exist([filelist{i} '.px'])					fprintf('No plexon data for %s.\n', filelist{i});					plex_successful = 0;					z1 = strmatch('plex', which_fields, 'exact');					z2 = strmatch('ctr', which_fields);					if ~isempty(z1)						if isempty(z2)							[which_fields{z1}] = deal('ctr');						else							which_fields(z1) = [];						end                    end					z1 = strmatch('plex', which_fields);                    which_fields(z1) = [];				else					fprintf('==> Loading %s plexon data.\n', filelist{i});					load([filelist{i} '.px'], '-mat');					bplex{successful_files} = plex;					bdropped{successful_files} = dropped;					clear plex				end			end		end		clear gvals	endendif successful_files == 0	mv = [];	returnendstate_list = lower([gpars.disp_names gpars.state_names]);fprintf('%d trials.\n', count);fprintf('Converting parameters.\n');mv = convert_pars2(bvals);wf = [];wf_done = 0;if nodata == 0	for i = 1:length(align_states)		if ~isempty(align_states{i}) & ~isempty(time_windows{i})			the_event = strmatch(align_states{i}, state_list, 'exact');			if ~isempty(the_event)				fprintf('Extracting %s aligned data.\n', align_states{i});				if plex_successful == 0					mv.a{i} = extract_aligned_data2(bvals, which_fields, the_event, time_windows{i});                else					[mv.a{i} all_fields all_which wf1 wf_done1] = extract_aligned_data2_plex_lfp(bvals, bplex, which_fields, the_event, time_windows{i}, wf_done);                    if wf_done1 && ~wf_done                        wf_done = wf_done1;                        wf = wf1;                    end				end			else				warning(['Could not find state ' align_states{i}]);                warning('Valid states are: ');                disp(state_list);			end		end    endend	mv.target.direction = degnorm(mv.target.direction);if isfield(mv, 'dist') & isfield(mv.dist, 'direction')	mv.dist.direction = degnorm(mv.dist.direction);endif isfield(mv, 'precue')	mv.precue.direction = degnorm(mv.precue.direction);endif isfield(mv, 'cue')	mv.cue.direction = degnorm(mv.cue.direction);endif isfield(mv, 'postcue')	mv.postcue.direction = degnorm(mv.postcue.direction);endmv.resp.srt = mv.resp.srt(1,:);mv.resp.sacx = mv.resp.sacx(1,:);mv.resp.sacy = mv.resp.sacy(1,:);mv.state_list = gpars.state_names;mv.disp_list = gpars.disp_names;mv.misc.plex_dropped = zeros(size(mv.trialnum));if plex_successful	mv.misc.plex_date = repmat(bplex{1}(1).date, size(mv.trialnum));	mv.misc.plex_time = repmat(bplex{1}(1).time, size(mv.trialnum));		for i = 1:successful_files		zz = find(mv.filenum == i & ismember(mv.trialnum, bdropped{i}));		mv.misc.plex_dropped(zz) = 1;	endend% special code to handle spike waveformsif wf_done    [a b] = size(wf);    for len1 = 1:a        for len2 = 1:b           if ~isempty(wf{len1, len2})               mv.wf(len1, len2).mean = mean(wf{len1, len2},2);               mv.wf(len1, len2).std = std(wf{len1, len2},0,2);               mv.wf(len1, len2).n = size(wf{len1, len2},2);           end        end    end    if any(strcmp('plexwfall', which_fields))        mv.wf.all = wf;    endendmv.align_events = align_states;mv.align_windows = time_windows;if exist('all_fields') && ~isempty('all_fields')    mv.align_data = all_fields;    mv.align_index = all_which;else    mv.align_fields = which_fields;end