function [spk, event, predata, trialsave, lfp, lfp_starttime, lfp_freq, waves] = plex_get_trial_lfp2(fid, header, channel_count, unit_count, lfp_count)% function [spk, event, predata, trialsave, lfp, lfp_starttime, lfp_freq, waves] = plex_get_trial_lfp2(fid, header)%% Reads one trial from .plx file and extracts the following:% spk{a,b} - spike timestamps for a units from b electrode channels % event - digital input timestamps (10 channels; channel 1 is trial start, channel 2 is trial end, 3-10 are user-defined synch events sent from mac during trial using dio_write command)% predata - strobed data sent by back before beginning of trial-- this is filenumber and trial number used for combining data with .mat data from mac% trialsave - was it a valid (saved) trial?% lfp - Local field potential data% lfp_freq - sampling rate for LFP data% waves - spike waveforms%% rmm 03/27/2011%% based on an older routine:% % function [spk, event, predata] = plex_get_trial(fid, header)%% Reads spike and event data from start signal until stop signal (strobed event zero).%% INPUT: %	fid -- file to search%	header: this is previously read from the file.%% OUTPUT:%	spk{1:units, 1:channels}  -- timestamps of spikes.%	event(1:10) -- timestamp for events (3-10). Only the last event of each type per trial is recorded, and no strobed events.%		special: starttime is event 1, endtime is event 2.%	predata -- any strobed data recorded before start signal (strobe 0).%if nargin < 2	error('Missing filespec or header');endif fid == -1	error('Invalid file');end% read file headerfreq = header(35);  % frequencyndsp = header(36);  % number of dsp channelsnevents = header(37); % number of external eventsnslow = header(38);  % number of slow channelsnpw = header(39);  % number of points in wavenpr = header(40);  % number of points before threshold%adfreq = adheader(10);adfreq = header(65);    % we tacked this on in plex_open_filelfp_freq = adfreq;% max_units = 6;      % arbitrary per-channel maxnext_spike = ones(max(unit_count), channel_count);% ad = ones(10000, nslow) .* nan; % if preallocating arbitrary max length of 10 secad = [];next_ad = ones(nslow,1);next_ad_snippet_starttime = ones(nslow,1) .* nan;lfp = [];lfp_starttime = ones(nslow,1) .* nan;event = ones(10,1) .* nan;predata = [];spk = [];waves = [];% preallocating these was substantially slower than dynamically allocating% for i = 1:max_units%     for j = 1:ndsp%         spk{i,j} = ones(2500,1) .* nan;%         waves{i,j} = ones(npw, 2500) .* nan;    % if preallocating arbitrary max length%     end% endfor i = 1:max(unit_count)    for j = 1:channel_count        spk{i,j} = [];        waves{i,j} = [];    endendtrialsave = 0;% Find start of record or report EOF.event(1) = plex_seek_event(fid, header, 258);   % look for the next <start of recording> marker, which delineate trialsif event(1) < 0			% no more trials.	returnend% Get predata, (which consists of file number, trial number, and strobed synchstart signal=0)unit = -1;ts = 0;while unit ~= 0 & ts ~= -1	[ts unit] = plex_seek_event(fid, header, 257);	predata = [predata unit];endif ts == -1	error('Couldn''t find start signal.');endevent(1) = ts;		% This is the synch start (strobe zero).% read the data for trialwhile feof(fid) == 0	type = fread(fid, 1, 'int16');	upperbyte = fread(fid, 1, 'int16');	ts = fread(fid, 1, 'int32');    time_stamp = ts ./ freq;	channel = fread(fid, 1, 'int16');	unit = fread(fid, 1, 'int16');	nwf = fread(fid, 1, 'int16');	nwords = fread(fid, 1, 'int16');	toread = nwords;	if toread > 0	  wf = fread(fid, toread, 'int16');	end	if type == 1        % unit timestamp		if unit > 0			spk{unit, channel}(next_spike(unit,channel)) = time_stamp;            waves{unit, channel}(:, next_spike(unit, channel)) = wf;			next_spike(unit,channel) = next_spike(unit,channel) + 1;		end   	elseif type == 4    % DIO event		if channel >= 3 & channel <= 10     % Event signal from mac			event(channel) = time_stamp;		elseif channel == 257 & unit == 255	% save signal (means that trial is valid)			trialsave = 1;		elseif channel == 259	% stop signal (end of trial)			event(2) = time_stamp;			break;%		else%			error('Problem parsing file');      % channel 1 or 2 come from%			TIM board -- not saved here (we use 1 or 2 for start/stop%			sigs).        end    elseif nwords > 0 & type == 5   % LFP snippet        channel = channel + 1;        if isnan(lfp_starttime(channel))    % first ad snippet            lfp_starttime(channel) = time_stamp;            next_ad_snippet_starttime(channel) = time_stamp;        end                if (time_stamp - next_ad_snippet_starttime(channel)) .* adfreq >= 1            keyboard            % error('Gap in A/D datastream');        end                ad(next_ad(channel):next_ad(channel)+nwords-1, channel) = wf(1:nwords);        next_ad(channel) = next_ad(channel) + nwords;        next_ad_snippet_starttime(channel) = time_stamp + nwords ./ adfreq;    end             endlfp = ad;% Discard empty entries -- do this if preallocating% lfp = ad(1:max(next_ad)-1, :);% for i = 1:max_units%     for j = 1:ndsp%         spk{i,j} = spk{i,j}(1:next_spike(i,j)-1);%         waves{i,j} = waves{i,j}(:, 1:next_spike(i,j)-1);%     end% end% % Advance to end of record.% [ts unit] = plex_seek_event(fid, header, 259);% if ts < 0% 	error('Problem finding end of record');% end