function plex = plex_replace_trial_lfp2(vals, spk, event, plexfilename, lfp, lfp_starttime, lfp_freq, waves, channel_count, unit_count, lfp_count)% function new = plex_replace_trial_lfp2(vals, spk, event, plexfilename, lfp, lfp_starttime, lfp_freq, waves)%% This function generates a plex structure which contains unit and field data from plexon which has been synchronized with the data saved in the mac's .mat file.% Note: Counter channel #1 from the mac is retained -- this corresponds to the counter used to measure stimulation pulses.% So plexon counters start w/ #2 and increase -- plex.ctr{a+1, b} corresponds to sorted unit #a from electrode #b.% Spike waveforms are also saved (but they are not synchronized to anything)%% rmm 03/27/2011 %% Convert event timestamps to offsets from plx_start.event(2:end) = event(2:end) - event(1);% Save old spikes% vals.old_ctr = vals.ctr;% vals.misc.old_ctr_start = vals.misc.ctr_start;% Substitute new spikesplex.ctr_start = vals.misc.plex_start;data_samples = floor((vals.misc.trial_end - vals.misc.plex_start) .* vals.misc.ctr_rate);plex.ctr = vals.ctr(1);         % save stim pulses from old countersplex.wf{1} = [];for i = 1:channel_count			% channels	for j = 1:unit_count(i)		% units        plex.ctr{j+1,i} = zeros(data_samples,1);        ind = floor((spk{j,i}-event(1)) .* vals.misc.ctr_rate)+1;   % convert ts to indices into spike array        ind(ind < 1) = [];                % Get rid of spikes before trial start        ind(ind > data_samples) = [];     % Get rid of spikes after trial end        doub = ind(diff(ind) == 0);       % Find inter-spike intervals shorter than 1 ms, if present        plex.ctr{j+1,i}(ind) = 1;        plex.ctr{j+1,i}(doub) = 2;        plex.wf{j+1,i} = waves{j,i};	endend% Add LFPsplex.lfp = [];data_samples = floor((vals.misc.trial_end - vals.misc.plex_start) .* lfp_freq);plex.lfp_rate = lfp_freq;for i = 1:length(lfp_starttime)    if ~isnan(lfp_starttime(i))        plex.lfp{i} = ones(data_samples,1) .* nan;            % Note: the first LFP fragment could start before OR after record start -- event(1)                if lfp_starttime(i) < event(1)            source_start_index = floor((event(1) - lfp_starttime(i)) .* lfp_freq) + 1;            source_end_index = min(size(lfp,1), source_start_index + data_samples - 1);            dest_start_index = 1;            dest_end_index = source_end_index - source_start_index + 1;        else            dest_start_index = floor((lfp_starttime(i) - event(1)) .* lfp_freq) + 1;            source_start_index = 1;            source_end_index = min(size(lfp,1), data_samples - dest_start_index + 1);            dest_end_index = dest_start_index + source_end_index - source_start_index;        end                plex.lfp{i}(dest_start_index:dest_end_index) = lfp(source_start_index:source_end_index, i);    else        plex.lfp{i} = [];    endend% Add plex_event timing struct.plex.event = event;% Update records for merge time/date and file.plex.date = {datestr(now,1)};plex.time = {datestr(now,13)};plex.name = plexfilename;plex.trialnum = vals.trialnum;